import os
import sys

def main():
    PTSRC = os.path.join( os.path.abspath(os.path.split(__file__)[0]), '..', 'ptsrc')

    search_packages = {
        'scandef' : {
            'name': 'scan.def',
            # def file to read from
            'source': os.path.join ( PTSRC, 'parser', 'scan.def' ),
            # line values in parser.pt to mark start and end of paste 
            'range_strs': [
                '{ ===== Pasted contents of scan.def, generated by S/SL from scan.ssl -',
                '{ ===== End of contents of scan.def }'
            ],
            # tuple to store indices of paste range
            'paste_range': None,
        },

        'parserdef': {
            'name': 'parser.def',
            'source': os.path.join ( PTSRC, 'parser', 'parser.def' ),
            'range_strs': [
                '{ ===== Pasted contents of parser.def, generated by S/SL from parser.ssl -',
                '{ ===== End of contents of parser.def }'
            ],
            'paste_range': None,
        }
    }


    with open( os.path.join(PTSRC, 'parser', 'parser.pt'), 'r') as pf:
        pf_lines = pf.readlines()
        
        # for l in [ lines[-1] ]:
        #     print(l.strip())

        for pkg in search_packages.values():
            # skip if source file does not exist
            if not os.path.exists (pkg['source']):
                print('"{}" does not exist! Skipped'.format(pkg['source']))
                continue

            # filter pf lines to get the lines that match with the start and end of paste sections
            interested_lines = list(filter(
                lambda (i, line): line.strip() in pkg['range_strs'],
                enumerate(pf_lines)
            ))

            if len(interested_lines) != 2:
                raise Exception('Invalid {} line matching:\n{}'.format(pkg['name'], interested_lines))

            # make sure the order is correct, paste start first then paste end
            for mstr, ( lindx, line ) in zip (pkg['range_strs'], interested_lines):
                if line.strip() != mstr:
                    raise Exception('Invalid line matching: Matched start lines and end lines are incorrect')

            # populate our paste range
            # index range that will be overwritten by source file content
            # start index is +3 to maintain space line
            # end indx is -2 to maintain space line
            paste_start, paste_end = ( interested_lines[0][0] + 3, interested_lines[1][0] - 2 )

            # open the source file and read lines
            with open ( pkg['source'], 'r' ) as sf:
                sf_lines = sf.readlines()

            # then make the replacement in pf_lines by combining line ranges
            pf_lines = pf_lines[:paste_start] + sf_lines + pf_lines[paste_end+1:]

            print('Pasted contents for {}'.format(pkg['name']))

    # write the output file
    with open( os.path.join(PTSRC, 'parser', 'parser.pt'), 'w' ) as tf:
        tf.writelines(pf_lines)

    



if __name__ == '__main__':
    sys.exit(main())