import os
import sys

def main():
    PTSRC = os.path.join( os.path.abspath(os.path.split(__file__)[0]), '..', 'ptsrc')

    print('Updating semantic.pt with def file')

    search_packages = {

        'semanticdef': {
            'name': 'semantic.def',
            'source': os.path.join ( PTSRC, 'semantic', 'semantic.def' ),
            'range_strs': [
                '{ ===== Pasted contents of semantic.def, generated by S/SL from semantic.ssl -',
                '{ ===== End of contents of semantic.def }'
            ],
            'paste_range': None,
        }
    }


    with open( os.path.join(PTSRC, 'semantic', 'semantic.pt'), 'r') as pf:
        pf_lines = pf.readlines()
        

        for pkg in search_packages.values():
            # skip if source file does not exist
            if not os.path.exists (pkg['source']):
                print('"{}" does not exist! Skipped'.format(pkg['source']))
                continue

            # filter pf lines to get the lines that match with the start and end of paste sections
            interested_lines = list(filter(
                lambda (i, line): line.strip() in pkg['range_strs'],
                enumerate(pf_lines)
            ))

            if len(interested_lines) != 2:
                raise Exception('Invalid {} line matching:\n{}'.format(pkg['name'], interested_lines))

            # make sure the order is correct, paste start first then paste end
            for mstr, ( lindx, line ) in zip (pkg['range_strs'], interested_lines):
                if line.strip() != mstr:
                    raise Exception('Invalid line matching: Matched start lines and end lines are incorrect')

            # populate our paste range
            # index range that will be overwritten by source file content
            # start index is +3 to maintain space line
            # end indx is -2 to maintain space line
            paste_start, paste_end = ( interested_lines[0][0] + 3, interested_lines[1][0] - 2 )

            # open the source file and read lines
            with open ( pkg['source'], 'r' ) as sf:
                sf_lines = sf.readlines()

            # then make the replacement in pf_lines by combining line ranges
            pf_lines = pf_lines[:paste_start] + sf_lines + pf_lines[paste_end+1:]

            print('Pasted contents for {}'.format(pkg['name']))

    # write the output file
    with open( os.path.join(PTSRC, 'semantic', 'semantic.pt'), 'w' ) as tf:
        tf.writelines(pf_lines)

    



if __name__ == '__main__':
    sys.exit(main())