#!/usr/bin/env bash
# prints assembly code for the program
# uses the -S but deletes the file immediately after
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

PTSRC_DIR=$SCRIPT_DIR/../build/ptsrc
LIB_PT_DIR=$PTSRC_DIR/lib/pt

if (( $# < 1 )) ; then
    echo "Must specify test file"
    exit 0
fi

if `test ! -f $1`; then
    echo "$1 is not a file!"
    exit 0
fi

flag=$2
keep_asm_file=0

if [[ "$flag" = "-f" ]]; then
    keep_asm_file=1
fi

# split provided path into dir and filename
parent=`echo $1 | sed -e 's#\(.*/\)\(.*\)#\1#'`
leaf=`echo $1 | sed -e 's#\(.*/\)\(.*\)#\2#'`
fname=`echo $leaf | sed -e 's#\(.*\)\(\.pt\)#\1#'`

if [[ "$parent" = "$leaf" ]]; then 
    parent=""
fi

if [[ "$keep_asm_file" = "1" ]]; then
    # dont use a temp file use the actual file name
    outputfile=$parent$fname
else
    outputfile=$parent"temp"
fi

# output the file to the console
# if keepasm file is on, then outputfile is the actual file
if [[ "$keep_asm_file" != "1" ]]; then
    # output to the tempfile
    cat $1 > $outputfile.pt
fi

errfile=asmscripterr.txt
ptc -L $LIB_PT_DIR -S $outputfile.pt > $errfile

errcont=`find ./ -empty -name $errfile`
error_occured=0

if [[ "$errcont" = "" ]]; then
    # we are looking for empty error file
    # if no empty error file is found, means error is non empty
    # so an error occured
    error_occured=1
    cat $errfile
fi

# delete the error file 
rm $errfile

if [[ "$error_occured" = "1" ]]; then
    # if an error occured
    # no output files were generated can exit here
    echo "An error occured compiling $1"
    if [[ "$keep_asm_file" != "1" ]]; then rm $outputfile.pt; fi
    exit 0
fi

if [[ "$keep_asm_file" != "1" ]]; then
    # output to the tempfile
    cat $outputfile.s
fi

if [[ "$keep_asm_file" != "1" ]]; then
    # delete the assembly file
    rm $outputfile.s
    rm $outputfile.pt
else
    echo ""
    echo "Output was saved to $outputfile.s"
fi