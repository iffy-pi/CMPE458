% just contains the declarations of tokens and types in a separate file to make it easier to search
%  PT Semantic Analysis Pass Version 5.1
%
%  Date  30 Jun 1980
%        (Revised v5.1 - 8 Feb 2021)
%
%  Author  Alan Rosselet
%
%  Abstract
%      The semantic analyzer gathers information about names and stores
%      that information in its symbol and type tables.  It enforces the 
%      context sensitive syntax of PT such as declaration before use.
%      It performs type compatibility checking in expressions, assignment
%      statements, call statements etc.  It assigns runtime addresses to
%      all data objects.  It generates a stream of PT intermediate code,
%      "t-code", corresponding semantically to the source program.

Input :
        sIdentifier 
        firstSemanticToken = sIdentifier
        firstCompoundSemanticToken = sIdentifier
        sInteger
        sStringLiteral
        lastCompoundSemanticToken = sStringLiteral

        sProgram
        sParmBegin
        sParmEnd
        sConst
        sType
        sVar
        sProcedure
        sBegin
        sEnd
        sNegate
        sArray
        sFile
        sRange
        sCaseStmt
        sCaseEnd
        sLabelEnd
        sExpnEnd
        sNullStmt
        sAssignmentStmt
        sSubscript
        sCallStmt
        sFieldWidth
        sIfStmt
        sThen
        sElse
        sWhileStmt
        sEq
        sNE
        sLT
        sLE
        sGT
        sGE
        sAdd
        sSubtract
        sMultiply
        sDivide
        sModulus
        sInfixOr
        sOr
        sInfixAnd
        sAnd
        sNot
        sNewLine

        % added semantic tokens
        sModule
        sDo
        sBreakIf
        sSubstring
        sLength
        sIndex
        sPublic
        % end added semantic tokens
        
        % to remove tokens (for semantic phase)
        sRepeatStmt
        sRepeatEnd
        % end remove tokens
        
        sEndOfFile
        lastSemanticToken = sEndOfFile;

Output :        
        % T-code tokens - must match input tokens in coder.ssl exactly!

        % Non-compound T-codes - T-code operations take no operands
        tMultiply 
        firstTcode = tMultiply
        tDivide
        tModulus
        tAdd
        tSubtract
        tEQ
        tNE
        tGT
        tGE
        tLT
        tLE
        tAnd
        tInfixAnd
        tOr
        tInfixOr
        tNegate
        tNot
        tChr
        tOrd
        tEoln
        tEOF
        tVarParm
        tFetchAddress
        tFetchInteger
        tFetchString
        tFetchBoolean
        tAssignBegin
        tAssignAddress
        tAssignInteger
        tAssignString
        tAssignBoolean
        tStoreAddress
        tStoreInteger
        tStoreString
        tStoreBoolean
        tSubscriptBegin
        tSubscriptAddress
        tSubscriptInteger
        tSubscriptString
        tSubscriptBoolean
        tArrayDescriptor
        tFileDescriptor
        tFileBind
        tIfBegin
        tIfEnd
        tCaseBegin
        tWhileBegin % to remove
        tRepeatBegin % to remove
        tRepeatControl % to remove
        tCallBegin
        tParmEnd
        tProcedureEnd
        tWriteBegin
        tReadBegin
        tTrapBegin
        tWriteEnd
        tReadEnd
        % New output tokens
        tConcatenate % string operators added here because same location as std operators
                        % dont take any operand themselves, take one of the compound codes
        tSubstring
        tLength
        tIndex
        tStringEqual

        tDoBegin % new item for do
        % end new output tokens

        % Compound T-codes - T-code operations that take an operand
        tLiteralAddress
        firstCompoundTcode = tLiteralAddress
        tLiteralInteger
        tLiteralBoolean
        tSkipString
        tStringData
        tLiteralString
        tIfThen
        tIfMerge
        tCaseSelect
        tCaseMerge
        tCaseEnd
        tWhileTest % to remove
        tWhileEnd % to remove 
        tRepeatTest % to remove
        tSkipProc
        tCallEnd
        tLineNumber
        % new compund t codes
        toDoBreakIf % compound to match ifthen t codes
        toDoTest % compound to match while t codes
        tDoEnd

        tCaseElse % new t code for case
                  % compound to match ifthen t codes
        % end new compound t codes
        tTrap
        lastCompoundTcode = tTrap
        % End of file marker T-code
        tEndOfFile
        lastTcode = tEndOfFile;

Error :
        eDuplicateName 
        firstErrorCode = eDuplicateName
        eMultiplyDefined
        eUndefinedIdentifier
        eConstantReqd
        eNullString
        eSubrangeReqd
        eScalarReqd
        eIntegerConstReqd
        eBounds
        eSimpleTypeReqd
        eExternalUndeclared
        eExternalDeclare
        eFileVarReqd
        eFileNameReqd
        eOperandOperatorTypeMismatch
        eNonScalarValParm
        eParameterTypeMismatch
        eInsufficientActuals
        eExtraActuals
        eRecursiveCall
        eProcedureReqd
        eTypeIdentifierReqd
        eIntegerExpnReqd
        eBooleanExpnReqd
        eCharExpnReqd
        eArrayVarReqd
        eVariableReqd
        eDuplicateLabel
        eExpnOperandReqd
        eTypeMismatch
        eInvalidExpn
        eInputNotVisible
        eOutputNotVisible
        eFieldWidth
        eTextFileVarReqd
        eWriteExpn
        eReadVar
        lastSslErrorCode = eReadVar;

type Integer :
        zero = 0
        one = 1
        two = 2
        three = 3
        ten = 10

        % These two sizes are machine dependent
        byteSize = 1
        wordSize = 4
        stringSize = 1024 % for maximum size of string
        ; 

type Boolean :
        no
        yes;

type PredeclaredId :
        % The predeclared identifiers of PT Pascal.
        % This list must be in the exact same order as the 
        % corresponding predeclared identifiers in the stdIdentifiers file.

        firstPredeclaredId = 1

        % Predeclared type names
        firstPredeclaredType = firstPredeclaredId
        pidInteger = firstPredeclaredType
        pidChar
        pidBoolean
        pidText
        lastPredeclaredType = pidText

        % Predeclared constant and procedure names
        pidTrue
        pidFalse
        pidReset
        pidRewrite
        pidWrite
        pidWriteln
        pidRead
        pidReadln
        pidChr
        pidOrd
        pidEoln
        pidEof
        pidAssign
        lastPredeclaredId = pidAssign

        % Predeclared program parameters
        pidInput
        firstSpecialId = pidInput
        pidOutput
        lastSpecialId = pidOutput;

type StdType :
        stdInteger
        stdString
        stdBoolean
        stdText;


mechanism SymbolTable :
    % The symbol table associates declared attributes with names.
    % A symbol table entry consists of 4 fields:  a name, a symbol kind
    % (e.g. variable, type), a value (e.g. constant value, variable
    % address) and a link to the symbol's type table entry.

    oSymbolTblEnter
        % Make a new symbol table entry with the attributes
        % of the top symbol in the symbol stack.

    oSymbolTblUpdate
        % The symbol table entry referenced by the top entry
        % in the symbol stack is given the attributes of the
        % top symbol stack entry.

    oSymbolTblPushScope
        % Push a lexic level stack entry and set it to refer
        % to the top entry in the symbol table.

    oSymbolTblPopScope
        % Pop the lexic level stack and unlink all names local to the scope.
        % Remove all local entries from the symbol and type tables.

    oSymbolTblPreserveParameters
        % Restore procedure parameter entries to the symbol table 
        % after popping the scope.

    oSymbolTblLookupExternal >> Boolean
        % Return true if any external names (program parameters)
        % have not yet been declared.

    % new symbol scope functions, add comment like the above
    oSymbolTblStripScope 

    oSymbolTblMergeScope
    ;


% Symbol Stack types and mechanism

type SymbolKind :
        syConstant
        syType
        syVariable
        syVarParameter
        syProcedure
        syFunction
        syExternal
        syExpression
        syUndefined;

type StdRoutine :
        rtReset = 1
        rtRewrite
        rtWrite
        rtWriteln
        rtRead
        rtReadln
        rtOrd
        rtChr
        rtEoln
        rtEof
        rtAssign
        rtNull;

type StdFile :
        stdInput
        stdOutput
        stdNull;


mechanism SymbolStack :
    % A symbol stack entry is a temporary copy of a symbol table
    % entry.  During declaration processing the attributes of a
    % name are built up in the symbol stack before being transferred
    % to an entry in the symbol table.  During statement processing
    % the symbol stack, using copies of symbol table entries, checks
    % that symbols are properly accessed.  The stack structure
    % allows arbitrary nesting of statements and expressions.
    % A symbol stack entry consists of five fields: a reference
    % to the associated symbol table entry, a name, a symbol kind, a
    % value or address and a reference to the type table entry
    % associated with this symbol.

    oSymbolStkPush (SymbolKind)
        % Push an entry and set its kind field to the parameter value.

    oSymbolStkPushIdentifier
        % Lookup the last accepted identifier in the symbol table.
        % If found, push an entry with the attributes of the symbol
        % table entry.  Otherwise, push an entry with kind syUndefined.

    oSymbolStkPushLocalIdentifier
        % Special case of PushIdentifier, the symbol table lookup is
        % restricted to the current scope.

    oSymbolStkPushStandardVariable (StdFile)
        % Used to push entries for the standard files input and output.
        % If the parameter variable was listed in the program heading
        % and is visible in the current scope, push an entry with
        % the variable's symbol table attributes, otherwise push an
        % entry with kind syUndefined.

    oSymbolStkPushFormalParameter
        % The top entry is a procedure symbol.  The top count stack
        % entry indicates which formal parameter is to be pushed
        % (e.g. first, second...). Push The indicated formal parameter
        % symbol, setting its attributes from its symbol table entry.

    oSymbolStkSetKind (SymbolKind)
        % Set the top entry's kind field to the parameter value.

    oSymbolStkEnterValue
        % The value field of the top entry is set to the value
        % of the top value stack entry.

    oSymbolStkEnterStringValue
        % The value field of the top entry is set to the character
        % value of the last accepted literal string (must be of length 1).

    oSymbolStkEnterDataAddress
        % The address field of the top entry is set to the current data
        % area free-address pointer.

    oSymbolStkEnterTypeReference
        % The top entry's type reference field is set to the type reference
        % field of the top type stack entry.

    oSymbolStkChooseKind >> SymbolKind
        % Return the value of the top entry's kind field.

    oSymbolStkChooseStandardFile >> StdFile
        % If the top entry is a standard variable (input or output) return
        % a value indicating which variable it is, otherwise return null.

    oSymbolStkChooseStandardRoutine >> StdRoutine
        % If the top entry is a standard routine symbol, return a
        % value indicating which routine it is, otherwise return null.

    oSymbolStkPop;
        % Pop the symbol stack

mechanism TypeTable :
    % A type table entry consists of 4 fields:  a type kind (e.g. integer,
    % char), a lower bound and an upper bound for array or subrange types
    % (these sometimes contain other information such as number of parameters
    % for a procedure) and a (possibly null) link to the type table entry
    % for the component type (used for array and file types).

    oTypeTblEnter
        % Make a new type table entry with the attributes of the 
        % top type stack entry.

    oTypeTblUpdate;
        % The type table entry referenced by the top entry in the
        % type stack is given the attributes of the top type stack entry.


% Type Stack types and mechanism

type TypeKind :
        tpInteger
        tpBoolean
        tpSubrange
        tpArray
        tpString        % special type for string literals
        tpFile
        tpNull;

mechanism TypeStack :
    % A type stack entry is a temporary copy of a type table
    % entry.  During declaration processing the attributes of a
    % name are built up in the type stack before being transferred
    % to an entry in the type table.  During statement processing
    % the type stack, using copies of type table entries, checks
    % that symbols are properly accessed.  The stack structure
    % allows arbitrary nesting of statements and expressions.
    % A type stack entry consists of five fields:  a reference
    % to the associated type table entry, a type kind, a lower
    % bound, an upper bound and a reference to the type table
    % entry for this type's component type.
    
    % TypeStackSlot = {
    %     TypeTable *typeTableEntry;  // the type table entry for this slot
    %     TypeKind kind; // the type kind for this slot
    %     int subrangeLowerBound; // lower bound of subrange
    %     int subrangeUpperBound; upper bound of subrange
    %     TypeTable *subrangeTypeTableEntry; // the type table entry for the subrange
    % }

    oTypeStkPush (TypeKind)
        % Push a type stack entry and set its kind to the parameter value.
        % TypeStack.push ( new TypeStackSlot( kind=TypeKind) )

    oTypeStkPushSymbol
        % Push an entry and set its attributes from the type table 
        % entry referenced by the top symbol stack entry.
        % TypeStack.push ( new TypeStackSlot( SymbolStack.top().typeTableEntry ) )

    oTypeStkPushComponent
        % Push an entry and set its attributes from the type table
        % entry referenced by the current top type stack entry.
        % TypeStack.push( new TypeStackSlot( TypeStack.top().typeTableEntry) )

    oTypeStkSetKind (TypeKind)
        % Set the top entry's kind field to the parameter value.
        % TypeStack.top().kind = TypeKind

    oTypeStkSetRecursionFlag (Boolean)
        % Mark the top entry, a procedure type, to indicate whether the
        % procedure is in the process of being defined.  Used to detect
        % self recursive calls.
        % TypeStack.top().recursionFlag = Boolean

    oTypeStkChooseRecursionFlag >> Boolean
        % Return the value of the top entry's recursion flag
        % return TypeStack.top().recursionFlag

    oTypeStkLinkToStandardType (StdType)
        % Set the top entry's type reference field to point to
        % the parameter standard type table entry.
        % TypeStack.top().typeTableEntry = TypeTable.findEntry(StdType)

    oTypeStkEnterBounds
        % Set the lower and upper bound fields of the top entry to
        % the top two values in the value stack (top value is upper bound).
        % TypeStack.top().upperBound = ValueStack.top()
        % TypeStack.top().lowerBound = ValueStack.top(1)

    oTypeStkVerifyBounds >> Boolean
        % Return true if the lower bound field of the top entry is less
        % than or equal to the upper bound field, return false otherwise.

    oTypeStkEnterParameterCount
        % Set the parameter count field of the top entry to the top
        % count stack value.

    oTypeStkCompareParameterCount >> Boolean
        % Return true if the top entry's parameter count field matches
        % the top count stack entry, otherwise return false.

    oTypeStkEnterComponentReference
        % Set the component reference field of the second entry to
        % the type reference field of the top entry. (The structure type
        % entry is beneath the component type entry on the stack.)

    oTypeStkChooseKind >> TypeKind
        % Return the value of the top entry's kind field.

    oTypeStkChooseTypeReference >> Boolean
        % Return true if the top entry's type reference field is non-null
        % (i.e. the entry has an associated type table entry), otherwise
        % return false.

    oTypeStkCompareNames >> Boolean
        % Return true is the top two entries were declared using the
        % same type name (i.e. their type reference fields refer to
        % the same type table entry), otherwise return false.

    oTypeStkSwap
        % Swap the top two entries

    oTypeStkPop;
        % Pop the type stack


% Emit type and mechanism

type TrapKind :
        trHalt = 0
        trReset = 1
        trRewrite = 2
        trRead = 3
        trReadln = 4
        trWrite = 5
        trWriteln = 6
        trWriteInteger = 8
        trWriteString = 109
        trReadInteger = 10
        trReadString = 108
        trAssign = 12;

mechanism Emit :
    % Emit writes to the output "t-code" stream (the code area),
    % incrementing the code area pointer as it does so.


    oEmitNullAddress
        % Emit a null address symbol as the operand of a forward
        % branch instruction to be replaced by a real address later
        % when the target becomes known.

    oEmitValue
        % Emit the value of the top value stack entry.

    oEmitString
        % Emit the text of the last accepted literal string token.

    oEmitDataAddress
        % Emit the current value of the data area free-address pointer.

    oEmitTrapKind (TrapKind)
        % Emit the parameter value which
        % identifies the last emitted trap instruction

    oEmitCaseBranchTable;
        % Emit a table of code addresses to be used to branch to a
        % selected case alternative statement.  The table is prefixed
        % by the lowest and highest label values which occurred in the
        % case statement.  The code addresses are emitted in ascending
        % order of corresponding label values.


mechanism Allocate :
    % Data allocation is performed statically,
    % so at the end of this pass the runtime
    % displacements of all variables are known.
    % The allocate mechanism alters only the data
    % area free-address pointer.

    oAllocateAlignOnWord
        % Machine dependent.  Align the data area free-address
        % pointer on a word boundary.

    oAllocateVariable
        % Allocate a variable of the type on top of the type stack 

    oAllocateVarParameter
        % Allocate space to hold an address.

    oAllocateDescriptor;
        % Allocate space for a data descriptor (array bound or file descriptor).


mechanism ValueStack :
    % The value stack holds integer values.  It is used during
    % declaration processing to handle values associated with
    % symbols (e.g. constant symbol values) and types (e.g. array
    % bounds).  It is used during statement processing to handle
    % values occurring in expressions.

    oValuePush (Integer)
        % Push the parameter value.

    oValuePushInteger
        % Push the value of the last-accepted integer token.

    oValuePushChar
        % Push the value of the last-accepted character string token.

    oValuePushStringLength
        % Push the length of the last-accepted character string token.

    oValuePushSymbol
        % Push the value field of the top symbol stack entry.

    oValuePushCount
        % Push the value of the top count stack entry.

    oValuePushTypeStkLowerBound
    oValuePushTypeStkUpperBound
        % Push the lower (upper) bound field of the top type stack entry.

    oValuePushCodeAddress
        % Push the current code area next address.

    oValueNegate
        % Negate the top entry.

    oValueChoose >> Integer
        % Return the value of the top entry.

    oValuePop;
        % Pop the value stack.


mechanism CaseStack :
    % The case stack mechanism is used only in processing case
    % statements.  A case stack entry consists of two fields:
    % a label value and a code area pointer which references the
    % statement which corresponds to that label value.  A case
    % stack display is used to handle nested case statements.

    oCasePushDisplay
        % Push a case display entry which references the current
        % top of the case label stack.  Used to handle nested cases.

    oCasePopDisplay
        % Set the case label stack top to the value of the case display
        % top and pop the case display.

    oCaseLookupLabel >> Boolean
        % Returns true if the top value stack entry matches a
        % label in the current-case-statement section (as indicated
        % by the case display) of the label stack.

    oCasePushLabel;
        % Push the top value stack entry onto the case label stack and
        % push the address of the next instruction to be emitted to the
        % code area which will be the case statement alternative
        % corresponding to the just-pushed label.


mechanism CountStack :
    % The count stack contains integer values.  It is used to
    % count items such as formal parameters.

    oCountPush (Integer)
        % Push the parameter value onto the count stack.

    oCountPushValue
        % Push the top value stack entry onto the count stack.

    oCountPop
        % Pop the count stack.

    oCountIncrement
        % Increment the value of the top count stack entry.

    oCountDecrement
        % Decrement the value of the top count stack entry.

    oCountChoose >> Integer;
        % Return the value of the top count stack entry.


mechanism FixAddress :
    % FixAddress is used to fill in the targets of forward branches
    % when they become known, and to remember the targets of
    % not-yet-emitted backward branches.

    oFixPushForwardBranch
        % Push the current code area pointer which is the address
        % of a forward branch instruction which must have its target
        % address filled in when it becomes known.

    oFixPopForwardBranch
        % Set the target address of the popped branch instruction
        % to be the current code area pointer.

    oFixPushTargetAddress
        % Push the current code area pointer which will serve as the target
        % address of a backward branch instruction to be emitted later.

    oFixPopTargetAddress
        % Set the target of the just-emitted backward branch instruction
        % to be the popped address.

    oFixPopAndEnterValue
        % Set the target of the popped branch instruction to be
        % the top value stack entry.

    oFixSwap;
        % Swap the top two fix stack entries.